'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handler = exports.importSpace = exports.builder = exports.desc = exports.command = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _context = require('../../context');

var _contentfulImport = require('contentful-import');

var _contentfulImport2 = _interopRequireDefault(_contentfulImport);

var _async = require('../../utils/async');

var _assertions = require('../../utils/assertions');

var _proxy = require('../../utils/proxy');

var _package = require('../../../package.json');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const command = exports.command = 'import';

const desc = exports.desc = 'import a space';

const builder = exports.builder = yargs => {
  return yargs.usage('Usage: contentful space import --content-file <file>').option('space-id', {
    describe: 'ID of the destination space',
    type: 'string'
  }).option('environment-id', {
    describe: 'ID the environment in the destination space',
    type: 'string',
    default: 'master',
    demand: false
  }).option('management-token', {
    alias: 'mt',
    describe: 'Contentful management API token',
    type: 'string'
  }).option('content-file', {
    describe: 'JSON file that contains data to be import to your space',
    type: 'string',
    demand: true
  }).option('content-model-only', {
    describe: 'Import only content types',
    type: 'boolean',
    default: false
  }).option('skip-content-model', {
    describe: 'Skip importing content types and locales',
    type: 'boolean',
    default: false
  }).option('skip-locales', {
    describe: 'Skip importing locales',
    type: 'boolean',
    default: false
  }).option('skip-content-publishing', {
    describe: 'Skips content publishing. Creates content but does not publish it',
    type: 'boolean',
    default: false
  }).option('no-update', {
    describe: 'Skips updating entries if they already exist',
    type: 'boolean',
    default: false
  }).option('error-log-file', {
    describe: 'Full path to the error log file',
    type: 'string'
  }).option('host', {
    describe: 'Management API host',
    type: 'string',
    default: 'api.contentful.com'
  }).option('proxy', {
    describe: 'Proxy configuration in HTTP auth format: [http|https]://host:port or [http|https]://user:password@host:port',
    type: 'string'
  }).config('config', 'An optional configuration JSON file containing all the options for a single run').epilog('Copyright 2018 Contentful, this is a BETA release');
};

const importSpace = exports.importSpace = async argv => {
  await (0, _assertions.assertLoggedIn)(argv);
  await (0, _assertions.assertSpaceIdProvided)(argv);

  let { cmaToken, activeSpaceId, proxy, rawProxy, host = 'api.contentful.com' } = await (0, _context.getContext)();
  const spaceId = argv.spaceId || activeSpaceId;
  const managementToken = argv.managementToken || cmaToken;
  const managementApplication = `contentful.cli/${_package.version}`;
  const managementFeature = argv.feature || `space-import`;
  host = argv.host || host;

  const options = _extends({}, argv, { spaceId, managementApplication, managementFeature, managementToken, host });
  if (proxy) {
    // contentful-import and contentful-export
    // expect a string for the proxy config
    // and create agents from it
    options.proxy = (0, _proxy.proxyObjectToString)(proxy);
    options.rawProxy = rawProxy;
  }
  return (0, _contentfulImport2.default)(options);
};
const handler = exports.handler = (0, _async.handleAsyncError)(importSpace);